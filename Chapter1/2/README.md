# 문제 - 큰 수의 법칙

'큰 수의 법칙'은 일반적으로 통계 분야에서 다루어지는 내용이지만 동빈이는 본인만의 방식으로 다르게 사용하고 있다. 동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때, **주어진 수들을 M번 더하여 가장 큰 수를 만드는 
법칙**이다. 단, 배열의 특정한 인덱스(번호)에 해당하는 **수가 연속해서 K번을 초과하여 더해질 수 없는 것**이 이 법칙의 특징이다. 예를 들어 순서대로 2,4,5,4,6 으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고
가장한다면, 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5 인 46이된다.단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.
예를 들어, 순서대로 3,4,3,4,3 으로 이루어진 배열이 있을때, M이 7이고, K가 2라고 가정하자. 이 경우 두번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다. 결과적으로
4+4+4+4+4+4+4인 28이 도출된다.


배열 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오

### 구현 알고리즘

```python
  n,m,k = map(int,input().split())
  number_list = list(map(int,input().split()))
  number_list.sort(reverse=True)
  
  result = 0
  count = 0
  i = 0
  
  while(m!=0):
    if(count_three==k):
      result+=number_list[i+1]
      count = 0
    else:
      result+=number_list[i]
      count+=1
    m-=1
  
  print(result)
```

### 이렇게 풀이한 이유

- sort를 사용해서 내림차순 정렬을 해준다 -> 가장 큰 수를 사용하기 위해서
- k번 더해질 수 있기 때문에, 더해진 횟수의 값을 나타내기위해 count변수를 선언한다.
- count가 k번째가 될때까지, 전달받은 배열의 수 중 가장 큰 수를 더해준다.
- 만약 더해진 횟수인 count가 k와 같은 값, 즉 k번만큼 더해졌을때, 배열의 수중 그 다음으로 큰 수를 한번 더해주고, count를 초기화 해준다.
- 전달받은 더해지는 횟수 M 만큼 반복하기 위해서, m-=1을 해준다.


### 책에 나온 알고리즘

```python
  first = number_list[0]
  second = number_list[1]
  big_count = m//(k+1)*k + m%(k+1)*k
  
  result = first+big_count + (m-big_count)*second
```

- big_count -> 가장 큰 수가 더해지는 횟수
- first -> 배열중에 가장 큰 수
- second -> 배열중에 두번째로 큰 수
