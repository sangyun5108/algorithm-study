# DFS/BFS

- 탐색(Search)이란 많은 양의 데이터 중에서 **원하는 데이터를 찾는 과정**을 말한다.
- 대표적인 그래프 탐색 알고리즘으로는 DFS와 BFS가 있다.
- **DFS/BFS는 코딩 테스트에서 매우 자주 등장하는 유형**이므로 반드시 숙지해야 한다.

### 스택 자료구조
- 먼저 들어온 데이터가 나중에 나가는 형식(선입후출)의 자료구조이다.
- **입구와 출구가 동일한 형태**로 스택을 시각화 할 수 있다.

ex) 박스 쌓기 예시


**스택 구현 예제**

```python
  stack = []
  
  # 삽입(5)-삽입(2)-삽입(3)-삽입(7)-삭제()-삽입(1)-삽입(4)-삭제()
  
 stack.append(5)
 stack.append(2)
 stack.append(3)
 stack.append(7)
 stack.pop()
 stack.append(1)
 stack.append(4)
 stack.pop()
 
 print(stack[::-1]) // [1,3,2,5] # 최상단 원소부터 출력
 print(stack) // [5,2,3,1] # 최하단 원소부터 출력
```

### 큐 자료구조

- 먼저 들어 온 데이터가 먼저 나가는 형식(선입선출)의 구조를 가진다.
- 큐는 **입구와 출구가 모두 뚫려있는 터널과 같은 형태**로 시각화가 가능하다.

**큐 구현 예제**
```python
  from collections import deque
  
  #큐 구현을 위해서 deque 라이브러리 사용
  # 삽입(5)-삽입(2)-삽입(3)-삽입(7)-삭제()-삽입(1)-삽입(4)-삭제()
  queue.append(5)
  queue.append(2)
  queue.append(3)
  queue.append(7)
  queue.popleft()
  queue.append(1)
  queue.append(4)
  queue.popleft()
  
  print(queue) # 먼저들어온 순서대로 출력  // deque([3,7,1,4])
  queue.reverse() # 다음 출력을 위해 역순으로 바꾸기 
  print(queue) # 나중에 들어온 원소부터 출력 // deque([4,1,7,3])
```
- list자료형이 아닌, deque를 이용하자!

### 재귀함수

- 재귀함수란 자기자신을 다시 호출하는 함수를 의미한다.

```python
  def recursive_function():
    print("재귀 함수를 호출합니다.')
    recursive_function()
 
  recursive_function()
```
- '재귀 함수를 호출합니다.' 라는 문자열을 무한히 출력한다.
- 어느 정도 출력하다가 최대 재귀 깊이 초과 메시지가 출력된다.


***재귀 함수의 종료 조건***

```python
  def recursive_function(i):
    # 100번째 호출을 했을 때 종료되도록 종료 조건 명시
    if i == 100:
      return
    recursive_function(i+1)
 
  recursive_function(1)
```
- 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수의 종료 조건을 반드시 명시해야 한다.
- 종료 조건을 제대로 명시하지 않으면 함수가 무한히 호출된다.

** 최대공약수 계산(유클리드 호재법)예제**

- 두 개의 자연수에 대한 최대공약수를 구하는 대표적인 알고리즘으로는 유클리드 호제법이 있다.

**유클리드 호재법**

- 두 자연수 A,B에 대하여 (A>B) A를 B로 나눈 나머지를 R이라고 한다.
- 이 때 **A와 B의 최대공약수**는 **B와 R의 최대 공약수**와 같다.

```python
  def gcd(a,b):
    if a%b == 0:
      return b
    else:
      return gcd(b,a%b)
```

**재귀 함수 사용의 유의사항**

- 재귀 함수를 잘 활용하면 복잡한 알고리즘을 간결하게 작성할 수 있다.
- 단, 오히려 다른 사람이 이해하기 어려운 형태의 코드가 될 수 있으므로 신중하게 사용해야 한다.
- 모든 재귀 함수는 반복문을 이용하여 동일한 기능을 구현할 수 있다.
- 재귀 함수가 반복문보다 유리한 경우도 있고 불리한 경우도 있다.
- 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓인다.
- 스택을 사용해야 할 때 구현상 **스택라이브러리 대신에 재귀 함수를 이용**하는 경우가 많다.

### DFS(Depth-First Search)

- DFS : Depth-First Search, 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.
- 그래프의 기본 구조 : 노드 + 간선, 노드 = 정점
- 그래프 탐색 : 하나의 노드를 시작으로 다수의 노드를 방문하는 것
- 두 노드가 간선으로 연결되어 있다 = '두 노드는 인접하다'
- 그래프 2 가지 방식 : 인접행렬, 인접 리스트
- 인접 행렬 : **2차원 배열**로 그래프와 연결 관계를 표현하는 방식
- 인접 리스트 : **리스트**로 그래프의 연결 관게를 표현하는 방식

**인접 행렬 방식**

```python
  INF = 999999999 # 무한의 비용 선언
  
  # 2차원 리스트를 이용해 인접 행렬 표현
  graph = [
    [0,7,5].
    [7,0,INF],
    [5,INF,0]
  ]
  
  print(graph) // [[0,7,5].[7,0,INF],[5,INF,0]]
```

**인접 리스트 방식**

```python
  #행(Row)이 3개인 2차원 리스트로 인접 리스트 표햔
  graph = [[] for_in range(3)]
  
  #노드 0에 연결된 노드 정보 저장(노드,거리)
  graph[0].append((1,7))
  graph[0].append((2,5))
  
  #노드 1에 연결된 노드 정보 저장(노드,거리)
  graph[1].append((0,7))
  
  #노드 2에 연결된 노드 정보 저장(노드,거리)
  graph[2].append((0,5))
  
  print(graph) // [[(1,7),(2,5)],[(0,7),(0,5)]]
```


### DFS 알고리즘

- 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙히 들어가서 노드를 방문한 후. 다시 돌아가 다른 경로를 탐색하는 알고리즘이다.

**구체적인 동작과정**
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고, 방문 처리를 한다. 방문하지 않은 인접 노드가 없는 경우, 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더이상 수행할 수 없을 때까지 반복한다.

- '방문 처리'는 스택에 한 번 삽입되어 처리된 노드가 다시 삽입되지 않게 체크하는 것을 의미한다. 방문 처리를 함으로써 각 노드를 한번씩만 처리할 수 있다.

**DFS 특징**
- DFS는 스택 자료구조에 기초한다는 점에서 구현이 간단하다.
- 데이터의 개수가 N개인 경우, O(N)의 시간이 소요된다는 특징이 있다.
- DFS는 스택을 이용하는 알고리즘 이므로, 실제 구현은 재귀 함수를 이용했을 때 매우 간결하게 구할 수 있다.

```python
  def dfs(graph,v,visited):
    #현재 노드를 방문처리
    visited[v] = True
    print(v,end='')
    #현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
      if not visited[i]:
        dfs(graph,i,visited)
    
    # 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
    graph=[
      [],
      [2,3,8],
      [1,7],
      [],4,5],
      [3,5],
      [3,4],
      [7],
      [2,6,8],
      [1,7]
    ]
    
    # 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
    visited = [False]*9
    
    # 정의된 DFS 함수 호출
    dfs(graph,1,visited)
    
```

```python
  1 2 7 6 8 3 4 5
```









